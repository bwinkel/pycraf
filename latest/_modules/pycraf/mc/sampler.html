
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pycraf.mc.sampler &#8212; pycraf v1.1.0</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pycraf.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery-rendered-html.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../../../_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">py</span><span id="logotext2">craf</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">pycraf v1.1.0</a>
	 &#187;
      </li>
      <li><a href="../../index.html" >Module code</a> &#187;</li>
      <li><a href="../../pycraf.html" accesskey="U">pycraf</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pycraf.mc.sampler</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;HistogramSampler&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="HistogramSampler"><a class="viewcode-back" href="../../../api/pycraf.mc.HistogramSampler.html#pycraf.mc.HistogramSampler">[docs]</a><span class="k">class</span> <span class="nc">HistogramSampler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Sampler to get random values obeying a discrete(!) density distribution.</span>

<span class="sd">    With this class, one can use discrete densities (think of them as</span>
<span class="sd">    binned entities, aka histograms) to get random samples that follow</span>
<span class="sd">    the same (binned) distribution as the histogram. For simplicity</span>
<span class="sd">    the returned values are the N-dim indices that need to be fed</span>
<span class="sd">    into the histogram bin-ranges if one wants to convert them</span>
<span class="sd">    to physical values (see examples, below).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    histvals : N-D `~numpy.ndarray`</span>
<span class="sd">        Discrete density distribution. (This is the histogram array, which</span>
<span class="sd">        one would get out of `~numpy.histogram` functions.)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hist_sampler : `~pycraf.mc.HistogramSampler`</span>
<span class="sd">        A `~pycraf.mc.HistogramSampler` instance.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    A trivial one-dimensional use case::</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from pycraf import mc</span>
<span class="sd">        &gt;&gt;&gt; from astropy.utils.misc import NumpyRNGContext</span>

<span class="sd">        &gt;&gt;&gt; with NumpyRNGContext(1):</span>
<span class="sd">        ...     x = np.random.normal(0, 1, 100)</span>

<span class="sd">        &gt;&gt;&gt; hist, bins = np.histogram(x, bins=16, range=(-4, 4))</span>
<span class="sd">        &gt;&gt;&gt; mid_points = (bins[1:] + bins[:-1]) / 2</span>

<span class="sd">        &gt;&gt;&gt; my_sampler = mc.HistogramSampler(hist)</span>
<span class="sd">        &gt;&gt;&gt; with NumpyRNGContext(1):</span>
<span class="sd">        ...     indices = my_sampler.sample(10)</span>
<span class="sd">        ...     # Note that you could also do</span>
<span class="sd">        ...     # indices = my_sampler(10)</span>
<span class="sd">        &gt;&gt;&gt; print(indices)</span>
<span class="sd">        [7 9 3 7 6 5 6 7 7 8]</span>

<span class="sd">        &gt;&gt;&gt; print(mid_points[indices])  # doctest: +FLOAT_CMP</span>
<span class="sd">        [-0.25  0.75 -2.25 -0.25 -0.75 -1.25 -0.75 -0.25 -0.25  0.25]</span>

<span class="sd">    Works equally simple in 2D::</span>

<span class="sd">        &gt;&gt;&gt; with NumpyRNGContext(1):</span>
<span class="sd">        ...     x = np.random.normal(0, 1, 1000)</span>
<span class="sd">        ...     y = np.random.normal(2, 2, 1000)</span>

<span class="sd">        &gt;&gt;&gt; hist2d, xbins, ybins = np.histogram2d(</span>
<span class="sd">        ...     x, y, bins=(16, 16), range=((-4, 4), (-6, 10))</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; xmids = (xbins[1:] + xbins[:-1]) / 2</span>
<span class="sd">        &gt;&gt;&gt; ymids = (ybins[1:] + ybins[:-1]) / 2</span>

<span class="sd">        &gt;&gt;&gt; my_sampler = mc.HistogramSampler(hist2d)</span>
<span class="sd">        &gt;&gt;&gt; with NumpyRNGContext(1):</span>
<span class="sd">        ...     indices = my_sampler.sample(10)</span>
<span class="sd">        &gt;&gt;&gt; print(list(zip(*indices)))</span>
<span class="sd">        [(7, 8), (9, 6), (1, 7), (7, 5), (6, 4),</span>
<span class="sd">         (5, 7), (6, 7), (7, 6), (7, 8), (8, 6)]</span>

<span class="sd">        &gt;&gt;&gt; print(list(zip(xmids[indices[0]], ymids[indices[1]])))  # doctest: +FLOAT_CMP</span>
<span class="sd">        [(-0.25, 2.5), (0.75, 0.5), (-3.25, 1.5), (-0.25, -0.5),</span>
<span class="sd">         (-0.75, -1.5), (-1.25, 1.5), (-0.75, 1.5), (-0.25, 0.5),</span>
<span class="sd">         (-0.25, 2.5), (0.25, 0.5)]</span>

<span class="sd">    It is also easily possible to apply weights. Just assume</span>
<span class="sd">    that one bin was observed exceptionally frequent::</span>

<span class="sd">        &gt;&gt;&gt; weights = np.ones_like(x)</span>
<span class="sd">        &gt;&gt;&gt; weights[500] = 1000</span>

<span class="sd">        &gt;&gt;&gt; hist2d, xbins, ybins = np.histogram2d(</span>
<span class="sd">        ...     x, y, bins=(16, 16), range=((-4, 4), (-6, 10)),</span>
<span class="sd">        ...     weights=weights</span>
<span class="sd">        ...     )</span>

<span class="sd">        &gt;&gt;&gt; my_sampler = mc.HistogramSampler(hist2d)</span>
<span class="sd">        &gt;&gt;&gt; with NumpyRNGContext(1):</span>
<span class="sd">        ...     indices = my_sampler.sample(10)</span>
<span class="sd">        &gt;&gt;&gt; print(list(zip(xmids[indices[0]], ymids[indices[1]])))  # doctest: +FLOAT_CMP</span>
<span class="sd">        [(-1.75, 4.5), (-0.25, 3.5), (-3.25, 1.5), (-1.75, 4.5),</span>
<span class="sd">         (-1.75, 4.5), (-1.75, 4.5), (-1.75, 4.5), (-1.75, 4.5),</span>
<span class="sd">         (-1.75, 4.5), (-1.25, 0.5)]</span>

<span class="sd">    As can be seen, the value `((1.25, -1.5))` is now exceptionally</span>
<span class="sd">    often sampled from the distribution.</span>

<span class="sd">    As discussed in the notes, for some use-cases a KDE might</span>
<span class="sd">    be the better tool::</span>

<span class="sd">        &gt;&gt;&gt; from scipy.stats import gaussian_kde  # doctest: +SKIP</span>

<span class="sd">        &gt;&gt;&gt; kernel = gaussian_kde((x, y))  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; with NumpyRNGContext(1):  # doctest: +SKIP</span>
<span class="sd">        ...     values = kernel.resample(10)</span>

<span class="sd">        &gt;&gt;&gt; print(*zip(values[0], values[1]))  # doctest: +SKIP +FLOAT_CMP</span>
<span class="sd">        [(-1.4708084392424643, 0.73081055816321849),</span>
<span class="sd">         (0.088396607804818894, 3.4075844477993105),</span>
<span class="sd">        ...</span>
<span class="sd">         (-2.0977896525658681, -0.2514770710536518),</span>
<span class="sd">         (0.26194085609813555, -0.93622928331194344)]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Even if you have continuous data to start with, using the histogram</span>
<span class="sd">    approach obviously works, as well (as is demonstrated in the examples).</span>
<span class="sd">    However, one looses the &quot;continuous&quot; property in the process.</span>
<span class="sd">    The resulting samples will always be just be able to work</span>
<span class="sd">    out the bin, but no continuous quantity can be reconstructed.</span>
<span class="sd">    For many use cases this is probably fine, but in others one</span>
<span class="sd">    might be better of by using Kernel Density Estimation.</span>
<span class="sd">    There is a function for this in `~scipy.stats`</span>
<span class="sd">    (`~scipy.stats.gaussian_kde`), which even allows works with</span>
<span class="sd">    multi-variate data and allows one to sample from the KDE PDF</span>
<span class="sd">    (see also the examples). Unfortunately, one cannot work with</span>
<span class="sd">    weighted data.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">histvals</span><span class="p">):</span>

        <span class="n">histvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">histvals</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_hshape</span> <span class="o">=</span> <span class="n">histvals</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span> <span class="o">=</span> <span class="n">histvals</span><span class="o">.</span><span class="n">ndim</span>
        <span class="c1"># cdf is flat, will need to unravel indices later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
            <span class="n">histvals</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="HistogramSampler.sample"><a class="viewcode-back" href="../../../api/pycraf.mc.HistogramSampler.html#pycraf.mc.HistogramSampler.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sample from the (discrete) density distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of samples to draw.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Indices : tuple of `~numpy.ndarray`</span>
<span class="sd">            The indices of the drawn samples with respect to the</span>
<span class="sd">            discrete density array (aka histogram object). See</span>
<span class="sd">            `~pycraf.mc.HistogramSampler` for examples of use.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">rsamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">rbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">,</span> <span class="n">rsamples</span><span class="p">)</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">rbins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hshape</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">indices</span></div>

<div class="viewcode-block" id="HistogramSampler.__call__"><a class="viewcode-back" href="../../../api/pycraf.mc.HistogramSampler.html#pycraf.mc.HistogramSampler.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Convenience method to allow using an *instance* of</span>
<span class="sd">        `~pycraf.mc.HistogramSampler` like a function::</span>

<span class="sd">            my_sampler = mc.HistogramSampler(hist)</span>
<span class="sd">            my_sampler(10)</span>

<span class="sd">        Calls `~pycraf.mc.HistogramSampler.sample` internally.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2021, Benjamin Winkel.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 4.0.3. &nbsp;
    Last built 07 Jul 2021. <br/>
  </p>
</footer>
  </body>
</html>