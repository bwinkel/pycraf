
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>astropy.units.quantity &#8212; pycraf v0.25.9.dev77</title>
    <link rel="stylesheet" href="../../../_static/pycraf.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>
<script type="text/javascript" src="../../../_static/copybutton.js"></script>


  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">py</span><span id="logotext2">craf</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">pycraf v0.25.9.dev77</a>
	 &#187;
      </li>
      <li><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astropy.units.quantity</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines the `Quantity` object, which represents a number with some</span>
<span class="sd">associated units. `Quantity` objects support operations like ordinary numbers,</span>
<span class="sd">but will deal with unit conversions internally.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span>
                        <span class="n">print_function</span><span class="p">)</span>

<span class="c1"># Standard library</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">Fraction</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># AstroPy</span>
<span class="kn">from</span> <span class="nn">..extern</span> <span class="k">import</span> <span class="n">six</span>
<span class="kn">from</span> <span class="nn">..extern.six.moves</span> <span class="k">import</span> <span class="nb">zip</span>
<span class="kn">from</span> <span class="nn">.core</span> <span class="k">import</span> <span class="p">(</span><span class="n">Unit</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">,</span> <span class="n">get_current_unit_registry</span><span class="p">,</span>
                   <span class="n">UnitBase</span><span class="p">,</span> <span class="n">UnitsError</span><span class="p">,</span> <span class="n">UnitTypeError</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.format.latex</span> <span class="k">import</span> <span class="n">Latex</span>
<span class="kn">from</span> <span class="nn">..utils.compat</span> <span class="k">import</span> <span class="n">NUMPY_LT_1_13</span><span class="p">,</span> <span class="n">NUMPY_LT_1_14</span><span class="p">,</span> <span class="n">NUMPY_LT_1_16</span>
<span class="kn">from</span> <span class="nn">..utils.compat.misc</span> <span class="k">import</span> <span class="n">override__dir__</span>
<span class="kn">from</span> <span class="nn">..utils.compat.numpy</span> <span class="k">import</span> <span class="n">matmul</span>
<span class="kn">from</span> <span class="nn">..utils.misc</span> <span class="k">import</span> <span class="n">isiterable</span><span class="p">,</span> <span class="n">InheritDocstrings</span>
<span class="kn">from</span> <span class="nn">..utils.data_info</span> <span class="k">import</span> <span class="n">ParentDtypeInfo</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">config</span> <span class="k">as</span> <span class="n">_config</span>
<span class="kn">from</span> <span class="nn">.quantity_helper</span> <span class="k">import</span> <span class="p">(</span><span class="n">converters_and_unit</span><span class="p">,</span> <span class="n">can_have_arbitrary_unit</span><span class="p">,</span>
                              <span class="n">check_output</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Quantity&quot;</span><span class="p">,</span> <span class="s2">&quot;SpecificTypeQuantity&quot;</span><span class="p">,</span>
           <span class="s2">&quot;QuantityInfoBase&quot;</span><span class="p">,</span> <span class="s2">&quot;QuantityInfo&quot;</span><span class="p">]</span>


<span class="c1"># We don&#39;t want to run doctests in the docstrings we inherit from Numpy</span>
<span class="n">__doctest_skip__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Quantity.*&#39;</span><span class="p">]</span>

<span class="n">_UNIT_NOT_INITIALISED</span> <span class="o">=</span> <span class="s2">&quot;(Unit not initialised)&quot;</span>
<span class="n">_UFUNCS_FILTER_WARNINGS</span> <span class="o">=</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arccosh</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arctanh</span><span class="p">}</span>


<span class="k">class</span> <span class="nc">Conf</span><span class="p">(</span><span class="n">_config</span><span class="o">.</span><span class="n">ConfigNamespace</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Configuration parameters for Quantity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">latex_array_threshold</span> <span class="o">=</span> <span class="n">_config</span><span class="o">.</span><span class="n">ConfigItem</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span>
        <span class="s1">&#39;The maximum size an array Quantity can be before its LaTeX &#39;</span>
        <span class="s1">&#39;representation for IPython gets &quot;summarized&quot; (meaning only the first &#39;</span>
        <span class="s1">&#39;and last few elements are shown with &quot;...&quot; between). Setting this to a &#39;</span>
        <span class="s1">&#39;negative number means that the value will instead be whatever numpy &#39;</span>
        <span class="s1">&#39;gets from get_printoptions.&#39;</span><span class="p">)</span>


<span class="n">conf</span> <span class="o">=</span> <span class="n">Conf</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">QuantityIterator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flat iterator object to iterate over Quantities</span>

<span class="sd">    A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity</span>
<span class="sd">    ``q``.  It allows iterating over the array as if it were a 1-D array,</span>
<span class="sd">    either in a for-loop or by calling its `next` method.</span>

<span class="sd">    Iteration is done in C-contiguous style, with the last index varying the</span>
<span class="sd">    fastest. The iterator can also be indexed using basic slicing or</span>
<span class="sd">    advanced indexing.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Quantity.flatten : Returns a flattened copy of an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It</span>
<span class="sd">    is not exported by the `~astropy.units` module.  Instead of</span>
<span class="sd">    instantiating a `QuantityIterator` directly, use `Quantity.flat`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span> <span class="o">=</span> <span class="n">q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">flat</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span>
        <span class="c1"># For single elements, ndarray.flat.__getitem__ returns scalars; these</span>
        <span class="c1"># need a new view as a Quantity.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the next value, or raise StopIteration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="p">)</span>
        <span class="c1"># ndarray.flat._dataiter returns scalars, so need a view as a Quantity.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="nb">next</span> <span class="o">=</span> <span class="fm">__next__</span>


<span class="k">class</span> <span class="nc">QuantityInfoBase</span><span class="p">(</span><span class="n">ParentDtypeInfo</span><span class="p">):</span>
    <span class="c1"># This is on a base class rather than QuantityInfo directly, so that</span>
    <span class="c1"># it can be used for EarthLocationInfo yet make clear that that class</span>
    <span class="c1"># should not be considered a typical Quantity subclass by Table.</span>
    <span class="n">attrs_from_parent</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">}</span>  <span class="c1"># dtype and unit taken from parent</span>
    <span class="n">_supports_indexing</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">default_format</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{0.value:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">possible_string_format_functions</span><span class="p">(</span><span class="n">format_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate through possible string-derived format functions.</span>

<span class="sd">        A string can either be a format specifier for the format built-in,</span>
<span class="sd">        a new-style format string, or an old-style format string.</span>

<span class="sd">        This method is overridden in order to suppress printing the unit</span>
<span class="sd">        in each row since it is already at the top in the column header.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="k">lambda</span> <span class="n">format_</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">format</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">format_</span><span class="p">)</span>
        <span class="k">yield</span> <span class="k">lambda</span> <span class="n">format_</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">format_</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">yield</span> <span class="k">lambda</span> <span class="n">format_</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">format_</span> <span class="o">%</span> <span class="n">val</span><span class="o">.</span><span class="n">value</span>


<span class="k">class</span> <span class="nc">QuantityInfo</span><span class="p">(</span><span class="n">QuantityInfoBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container for meta information like name, description, format.  This is</span>
<span class="sd">    required when the object is used as a mixin column within a table, but can</span>
<span class="sd">    be used as a general way to store meta information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_represent_as_dict_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">map</span><span class="p">):</span>
        <span class="c1"># Need to pop value because different Quantity subclasses use</span>
        <span class="c1"># different first arg name for the value.  :-(</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_cls</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="nb">map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">metadata_conflicts</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new Quantity instance which is consistent with the</span>
<span class="sd">        input ``cols`` and has ``length`` rows.</span>

<span class="sd">        This is intended for creating an empty column object whose elements can</span>
<span class="sd">        be set in-place for table operations like join or vstack.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cols : list</span>
<span class="sd">            List of input columns</span>
<span class="sd">        length : int</span>
<span class="sd">            Length of the output column object</span>
<span class="sd">        metadata_conflicts : str (&#39;warn&#39;|&#39;error&#39;|&#39;silent&#39;)</span>
<span class="sd">            How to handle metadata conflicts</span>
<span class="sd">        name : str</span>
<span class="sd">            Output column name</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        col : Quantity (or subclass)</span>
<span class="sd">            Empty instance of this class consistent with ``cols``</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get merged info attributes like shape, dtype, format, description, etc.</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_cols_attributes</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">metadata_conflicts</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                                           <span class="p">(</span><span class="s1">&#39;meta&#39;</span><span class="p">,</span> <span class="s1">&#39;format&#39;</span><span class="p">,</span> <span class="s1">&#39;description&#39;</span><span class="p">))</span>

        <span class="c1"># Make an empty quantity using the unit of the last one.</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span><span class="p">,)</span> <span class="o">+</span> <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">)</span>
        <span class="c1"># Use zeros so we do not get problems for Quantity subclasses such</span>
        <span class="c1"># as Longitude and Latitude, which cannot take arbitrary values.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Get arguments needed to reconstruct class</span>
        <span class="nb">map</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="p">(</span><span class="n">data</span> <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;value&#39;</span> <span class="k">else</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="p">))</span>
               <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_represent_as_dict_attrs</span><span class="p">}</span>
        <span class="nb">map</span><span class="p">[</span><span class="s1">&#39;copy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_dict</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>

        <span class="c1"># Set remaining info attributes</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>


<span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">InheritDocstrings</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A `~astropy.units.Quantity` represents a number with some associated unit.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value : number, `~numpy.ndarray`, `Quantity` object (sequence), str</span>
<span class="sd">        The numerical value of this quantity in the units given by unit.  If a</span>
<span class="sd">        `Quantity` or sequence of them (or any other valid object with a</span>
<span class="sd">        ``unit`` attribute), creates a new `Quantity` object, converting to</span>
<span class="sd">        `unit` units as needed.  If a string, it is converted to a number or</span>
<span class="sd">        `Quantity`, depending on whether a unit is present.</span>

<span class="sd">    unit : `~astropy.units.UnitBase` instance, str</span>
<span class="sd">        An object that represents the unit associated with the input value.</span>
<span class="sd">        Must be an `~astropy.units.UnitBase` object or a string parseable by</span>
<span class="sd">        the :mod:`~astropy.units` package.</span>

<span class="sd">    dtype : ~numpy.dtype, optional</span>
<span class="sd">        The dtype of the resulting Numpy array or scalar that will</span>
<span class="sd">        hold the value.  If not provided, it is determined from the input,</span>
<span class="sd">        except that any input that cannot represent float (integer and bool)</span>
<span class="sd">        is converted to float.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), then the value is copied.  Otherwise, a copy will</span>
<span class="sd">        only be made if ``__array__`` returns a copy, if value is a nested</span>
<span class="sd">        sequence, or if a copy is needed to satisfy an explicitly given</span>
<span class="sd">        ``dtype``.  (The `False` option is intended mostly for internal use,</span>
<span class="sd">        to speed up initialization where a copy is known to have been made.</span>
<span class="sd">        Use with care.)</span>

<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;}, optional</span>
<span class="sd">        Specify the order of the array.  As in `~numpy.array`.  This parameter</span>
<span class="sd">        is ignored if the input is a `Quantity` and ``copy=False``.</span>

<span class="sd">    subok : bool, optional</span>
<span class="sd">        If `False` (default), the returned array will be forced to be a</span>
<span class="sd">        `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,</span>
<span class="sd">        or a subclass appropriate for the unit will be used (such as</span>
<span class="sd">        `~astropy.units.Dex` for ``u.dex(u.AA)``).</span>

<span class="sd">    ndmin : int, optional</span>
<span class="sd">        Specifies the minimum number of dimensions that the resulting array</span>
<span class="sd">        should have.  Ones will be pre-pended to the shape as needed to meet</span>
<span class="sd">        this requirement.  This parameter is ignored if the input is a</span>
<span class="sd">        `Quantity` and ``copy=False``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the value provided is not a Python numeric type.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the unit provided is not either a :class:`~astropy.units.Unit`</span>
<span class="sd">        object or a parseable string unit.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Quantities can also be created by multiplying a number or array with a</span>
<span class="sd">    :class:`~astropy.units.Unit`. See http://docs.astropy.org/en/latest/units/</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Need to set a class-level default for _equivalencies, or</span>
    <span class="c1"># Constants can not initialize properly</span>
    <span class="n">_equivalencies</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Default unit for initialization; can be overridden by subclasses,</span>
    <span class="c1"># possibly to `None` to indicate there is no default unit.</span>
    <span class="n">_default_unit</span> <span class="o">=</span> <span class="n">dimensionless_unscaled</span>

    <span class="c1"># Ensures views have an undefined unit.</span>
    <span class="n">_unit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">10000</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># convert unit first, to avoid multiple string-&gt;unit conversions</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="c1"># if we allow subclasses, allow a class from the unit.</span>
            <span class="k">if</span> <span class="n">subok</span><span class="p">:</span>
                <span class="n">qcls</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="s1">&#39;_quantity_class&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">qcls</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
                    <span class="bp">cls</span> <span class="o">=</span> <span class="n">qcls</span>

        <span class="c1"># optimize speed for Quantity with no dtype given, copy=False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
                <span class="c1"># the above already makes a copy (with float dtype)</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">cls</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">subok</span> <span class="ow">and</span>
                                               <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">value</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                            <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">)</span>

        <span class="c1"># Maybe str, or list/tuple of Quantity? If so, this may set value_unit.</span>
        <span class="c1"># To ensure array remains fast, we short-circuit it.</span>
        <span class="n">value_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="c1"># The first part of the regex string matches any integer/float;</span>
                <span class="c1"># the second parts adds possible trailing .+-, which will break</span>
                <span class="c1"># the float function below and ensure things like 1.2.3deg</span>
                <span class="c1"># will not work.</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*[+-]?&#39;</span>
                           <span class="sa">r</span><span class="s1">&#39;((\d+\.?\d*)|(\.\d+)|([nN][aA][nN])|&#39;</span>
                           <span class="sa">r</span><span class="s1">&#39;([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))&#39;</span>
                           <span class="sa">r</span><span class="s1">&#39;([eE][+-]?\d+)?&#39;</span>
                           <span class="sa">r</span><span class="s1">&#39;[.+-]?&#39;</span><span class="p">)</span>

                <span class="n">v</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">unit_string</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>

                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot parse &quot;</span><span class="si">{0}</span><span class="s1">&quot; as a </span><span class="si">{1}</span><span class="s1">. It does not &#39;</span>
                                    <span class="s1">&#39;start with a number.&#39;</span>
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

                <span class="n">unit_string</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">string</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">end</span><span class="p">():]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">unit_string</span><span class="p">:</span>
                    <span class="n">value_unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit_string</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">unit</span> <span class="o">=</span> <span class="n">value_unit</span>  <span class="c1"># signal no conversion needed below.</span>

            <span class="k">elif</span> <span class="p">(</span><span class="n">isiterable</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span>
                  <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">)):</span>
                <span class="c1"># Convert all quantities to the same unit.</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
                <span class="n">value_unit</span> <span class="o">=</span> <span class="n">unit</span>  <span class="c1"># signal below that conversion has been done</span>

        <span class="k">if</span> <span class="n">value_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If the value has a `unit` attribute and if not None</span>
            <span class="c1"># (for Columns with uninitialized unit), treat it like a quantity.</span>
            <span class="n">value_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Default to dimensionless for no (initialized) unit attribute.</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_default_unit</span>
                <span class="n">value_unit</span> <span class="o">=</span> <span class="n">unit</span>  <span class="c1"># signal below that no conversion is needed</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value_unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">value_unit</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The unit attribute </span><span class="si">{0!r}</span><span class="s2"> of the input could &quot;</span>
                                    <span class="s2">&quot;not be parsed as an astropy Unit, raising &quot;</span>
                                    <span class="s2">&quot;the following exception:</span><span class="se">\n</span><span class="si">{1}</span><span class="s2">&quot;</span>
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">value_unit</span>
                <span class="k">elif</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">value_unit</span><span class="p">:</span>
                    <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># copy will be made in conversion at end</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                         <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">)</span>

        <span class="c1"># check that array contains numbers or long int objects</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;OSU&#39;</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span> <span class="ow">and</span>
                 <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">item</span><span class="p">(()</span> <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">),</span>
                            <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The value must be a valid Python or &quot;</span>
                            <span class="s2">&quot;Numpy numeric type.&quot;</span><span class="p">)</span>

        <span class="c1"># by default, cast any integer, boolean, etc., to float</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                              <span class="ow">or</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">value</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">value_unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="n">value_unit</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># here we had non-Quantity input that had a &quot;unit&quot; attribute</span>
            <span class="c1"># with a unit different from the desired one.  So, convert.</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c1"># If our unit is not set and obj has a valid one, use it.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_unit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

        <span class="c1"># Copy info if the original had `info` defined.  Because of the way the</span>
        <span class="c1"># DataInfo works, `&#39;info&#39; in obj.__dict__` is False until the</span>
        <span class="c1"># `info` attribute is accessed or set.  Note that `obj` can be an</span>
        <span class="c1"># ndarray which doesn&#39;t have a `__dict__`.</span>
        <span class="k">if</span> <span class="s1">&#39;info&#39;</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">info</span>

    <span class="k">def</span> <span class="nf">__array_prepare__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># This method gets called by Numpy whenever a ufunc is called on the</span>
        <span class="c1"># array. The object passed in ``obj`` is an empty version of the</span>
        <span class="c1"># output array which we can e.g. change to an array sub-class, add</span>
        <span class="c1"># attributes to, etc. After this is called, then the ufunc is called</span>
        <span class="c1"># and the values in this empty array are set.</span>

        <span class="c1"># In principle, this should not be needed any more in numpy &gt;= 1.13,</span>
        <span class="c1"># but it is still called in some np.linalg modules.</span>

        <span class="c1"># If no context is set, just return the input</span>
        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span>

        <span class="c1"># Find out which ufunc is being used</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="n">function</span><span class="o">.</span><span class="n">nin</span><span class="p">]</span>
        <span class="c1"># determine required converter functions -- to bring the unit of the</span>
        <span class="c1"># input to that expected (e.g., radian for np.sin), or to get</span>
        <span class="c1"># consistent units between two inputs (e.g., in np.add) --</span>
        <span class="c1"># and the unit of the result</span>
        <span class="n">converters</span><span class="p">,</span> <span class="n">result_unit</span> <span class="o">=</span> <span class="n">converters_and_unit</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">,</span>
                                                      <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">nout</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result_unit</span> <span class="o">=</span> <span class="n">result_unit</span><span class="p">[</span><span class="n">context</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

        <span class="c1"># We now prepare the output object</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">obj</span><span class="p">:</span>
            <span class="c1"># this happens if the output object is self, which happens</span>
            <span class="c1"># for in-place operations such as q1 += q2</span>

            <span class="c1"># Check that we&#39;re not trying to store a plain Numpy array or a</span>
            <span class="c1"># Quantity with an inconsistent unit (e.g., not angular for Angle),</span>
            <span class="c1"># and that we can handle the type (e.g., that we are not int when</span>
            <span class="c1"># float is required).</span>
            <span class="n">check_output</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">result_unit</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span> <span class="k">if</span> <span class="n">converter</span> <span class="ow">and</span> <span class="n">converter</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.</span> <span class="o">!=</span> <span class="mf">0.</span>
                 <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">converter</span> <span class="ow">in</span> <span class="n">converters</span><span class="p">)),</span>
                         <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>  <span class="c1"># no view needed since already a Quantity.</span>

            <span class="c1"># in principle, if self is also an argument, it could be rescaled</span>
            <span class="c1"># here, since it won&#39;t be needed anymore.  But maybe not change</span>
            <span class="c1"># inputs before the calculation even if they will get destroyed</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># normal case: set up output as a Quantity</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">result_unit</span><span class="p">)</span>

        <span class="c1"># We now need to treat the case where the inputs have to be converted -</span>
        <span class="c1"># the issue is that we can&#39;t actually convert the inputs since that</span>
        <span class="c1"># would be changing the objects passed to the ufunc, which would not</span>
        <span class="c1"># be expected by the user.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">converters</span><span class="p">):</span>

            <span class="c1"># If self is both output and input (which happens for in-place</span>
            <span class="c1"># operations), input will get overwritten with junk. To avoid</span>
            <span class="c1"># that, hide it in a new object</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">obj</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
                <span class="c1"># but with two outputs it would become unhidden too soon</span>
                <span class="c1"># [ie., np.modf(q1, q1, other)].  Bail.</span>
                <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">function</span><span class="o">.</span><span class="n">nout</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot apply multi-output </span><span class="si">{0}</span><span class="s2"> function &quot;</span>
                                    <span class="s2">&quot;to quantities with in-place replacement &quot;</span>
                                    <span class="s2">&quot;of an input by any but the last output.&quot;</span>
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

                <span class="c1"># If self is already contiguous, we don&#39;t need to do</span>
                <span class="c1"># an additional copy back into the original array, so</span>
                <span class="c1"># we store it in `result._result`.  Otherwise, we</span>
                <span class="c1"># store it in `result._contiguous`.  `__array_wrap__`</span>
                <span class="c1"># knows how to handle putting either form back into</span>
                <span class="c1"># the original array.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">]:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">_contiguous</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># ensure we remember the converter functions we need</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_converters</span> <span class="o">=</span> <span class="n">converters</span>

            <span class="k">if</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">_UFUNCS_FILTER_WARNINGS</span><span class="p">:</span>
                <span class="c1"># Filter out RuntimeWarning&#39;s caused by the ufunc being called on</span>
                <span class="c1"># the unscaled quantity first (e.g., np.arcsin(15*u.pc/u.kpc))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_catch_warnings</span> <span class="o">=</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_catch_warnings</span><span class="o">.</span><span class="fm">__enter__</span><span class="p">()</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                                        <span class="n">message</span><span class="o">=</span><span class="s1">&#39;invalid value encountered in&#39;</span><span class="p">,</span>
                                        <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="c1"># unit output will get (setting _unit could prematurely change input</span>
        <span class="c1"># if obj is self, which happens for in-place operations; see above)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_result_unit</span> <span class="o">=</span> <span class="n">result_unit</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Methods like .squeeze() created a new `ndarray` and then call</span>
            <span class="c1"># __array_wrap__ to turn the array into self&#39;s subclass.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># with context defined, we are continuing after a ufunc evaluation.</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_result_unit&#39;</span><span class="p">):</span>
                <span class="n">result_unit</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_result_unit</span>
                <span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="n">_result_unit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result_unit</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># We now need to re-calculate quantities for which the input</span>
            <span class="c1"># needed to be scaled.</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_converters&#39;</span><span class="p">):</span>

                <span class="n">converters</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_converters</span>
                <span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="n">_converters</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_catch_warnings&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_catch_warnings</span><span class="o">.</span><span class="fm">__exit__</span><span class="p">()</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_catch_warnings</span>

                <span class="c1"># For in-place operations, input will get overwritten with</span>
                <span class="c1"># junk. To avoid that, we hid it in a new object in</span>
                <span class="c1"># __array_prepare__ and retrieve it here.</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_result&#39;</span><span class="p">):</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_result</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_contiguous&#39;</span><span class="p">):</span>
                    <span class="n">obj</span><span class="p">[()]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_contiguous</span>
                    <span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="n">_contiguous</span>

                <span class="c1"># take array view to which output can be written without</span>
                <span class="c1"># getting back here</span>
                <span class="n">obj_array</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

                <span class="c1"># Find out which ufunc was called and with which inputs</span>
                <span class="n">function</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="n">function</span><span class="o">.</span><span class="n">nin</span><span class="p">]</span>

                <span class="c1"># Set the inputs, rescaling as necessary</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">converter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">converters</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">converter</span><span class="p">:</span>
                        <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">converter</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># with no conversion, input can be non-Quantity.</span>
                        <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="n">arg</span><span class="p">))</span>

                <span class="c1"># For output arrays that require scaling, we can reuse the</span>
                <span class="c1"># output array to perform the scaling in place, as long as the</span>
                <span class="c1"># array is not integral. Here, we set the obj_array to `None`</span>
                <span class="c1"># when it cannot be used to store the scaled result.</span>
                <span class="c1"># Use a try/except, since np.result_type can fail, which would</span>
                <span class="c1"># break the wrapping #4770.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">tmp_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>
                <span class="c1"># Catch the appropriate exceptions: TypeError or ValueError in</span>
                <span class="c1"># case the result_type raised an Exception, i.e. inputs is list</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                    <span class="n">obj_array</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Explicitly check if it can store the result.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result_unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">tmp_dtype</span><span class="p">,</span> <span class="n">obj_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)):</span>
                        <span class="n">obj_array</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Re-compute the output using the ufunc</span>
                <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_array</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inputs</span> <span class="o">+=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">obj_array</span><span class="p">]</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">obj_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">nout</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">context</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">result_unit</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">result_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># return a plain array</span>
                <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>  <span class="c1"># all OK now, so set unit.</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">result_unit</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrap numpy ufuncs, taking care of units.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : callable</span>
<span class="sd">            ufunc to wrap.</span>
<span class="sd">        method : str</span>
<span class="sd">            Ufunc method: ``__call__``, ``at``, ``reduce``, etc.</span>
<span class="sd">        inputs : tuple</span>
<span class="sd">            Input arrays.</span>
<span class="sd">        kwargs : keyword arguments</span>
<span class="sd">            As passed on, with ``out`` containing possible quantity output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : `~astropy.units.Quantity`</span>
<span class="sd">            Results of the ufunc, with the unit set properly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine required conversion functions -- to bring the unit of the</span>
        <span class="c1"># input to that expected (e.g., radian for np.sin), or to get</span>
        <span class="c1"># consistent units between two inputs (e.g., in np.add) --</span>
        <span class="c1"># and the unit of the result (or tuple of units for nout &gt; 1).</span>
        <span class="n">converters</span><span class="p">,</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">converters_and_unit</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Avoid loop back by turning any Quantity output into array views.</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If pre-allocated output is used, check it is suitable.</span>
            <span class="c1"># This also returns array view, to ensure we don&#39;t loop back.</span>
            <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">out_array</span> <span class="o">=</span> <span class="n">check_output</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">)</span>
            <span class="c1"># Ensure output argument remains a tuple.</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_array</span><span class="p">,)</span> <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">out_array</span>

        <span class="c1"># Same for inputs, but here also convert if necessary.</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">converter</span><span class="p">(</span><span class="n">input_</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">converter</span> <span class="k">else</span>
                        <span class="nb">getattr</span><span class="p">(</span><span class="n">input_</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="n">input_</span><span class="p">))</span>
                       <span class="k">for</span> <span class="n">input_</span><span class="p">,</span> <span class="n">converter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">converters</span><span class="p">))</span>

        <span class="c1"># Call our superclass&#39;s __array_ufunc__</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Quantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                                                       <span class="o">*</span><span class="n">arrays</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># If unit is None, a plain array is expected (e.g., comparisons), which</span>
        <span class="c1"># means we&#39;re done.</span>
        <span class="c1"># We&#39;re also done if the result was None (for method &#39;at&#39;) or</span>
        <span class="c1"># NotImplemented, which can happen if other inputs/outputs override</span>
        <span class="c1"># __array_ufunc__; hopefully, they can then deal with us.</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_as_quantity</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_result_as_quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn result into a quantity with the given unit.</span>

<span class="sd">        If no output is given, it will take a view of the array as a quantity,</span>
<span class="sd">        and set the unit.  If output is given, those should be quantity views</span>
<span class="sd">        of the result arrays, and the function will just set the unit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        result : `~numpy.ndarray` or tuple of `~numpy.ndarray`</span>
<span class="sd">            Array(s) which need to be turned into quantity.</span>
<span class="sd">        unit : `~astropy.units.Unit` or None</span>
<span class="sd">            Unit for the quantities to be returned (or `None` if the result</span>
<span class="sd">            should not be a quantity).  Should be tuple if result is a tuple.</span>
<span class="sd">        out : `~astropy.units.Quantity` or None</span>
<span class="sd">            Possible output quantity. Should be `None` or a tuple if result</span>
<span class="sd">            is a tuple.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~astropy.units.Quantity`</span>
<span class="sd">           With units set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_result_as_quantity</span><span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">unit_</span><span class="p">,</span> <span class="n">out_</span><span class="p">)</span>
                         <span class="k">for</span> <span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">unit_</span><span class="p">,</span> <span class="n">out_</span><span class="p">)</span> <span class="ow">in</span>
                         <span class="nb">zip</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># View the result array as a Quantity with the proper unit.</span>
            <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

        <span class="c1"># For given output, just set the unit. We know the unit is not None and</span>
        <span class="c1"># the output is of the correct Quantity subclass, as it was passed</span>
        <span class="c1"># through check_output.</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__quantity_subclass__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overridden by subclasses to change what kind of view is</span>
<span class="sd">        created based on the output unit of an operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : UnitBase</span>
<span class="sd">            The unit for which the appropriate class should be returned</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple :</span>
<span class="sd">            - `Quantity` subclass</span>
<span class="sd">            - bool: True is subclasses of the given class are ok</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Quantity</span><span class="p">,</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Quantity view of some array-like input, and set the unit</span>

<span class="sd">        By default, return a view of ``obj`` of the same class as ``self`` and</span>
<span class="sd">        with the same unit.  Subclasses can override the type of class for a</span>
<span class="sd">        given unit using ``__quantity_subclass__``, and can ensure properties</span>
<span class="sd">        other than the unit are copied using ``__array_finalize__``.</span>

<span class="sd">        If the given unit defines a ``_quantity_class`` of which ``self``</span>
<span class="sd">        is not an instance, a view using this class is taken.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj : ndarray or scalar, optional</span>
<span class="sd">            The array to create a view of.  If obj is a numpy or python scalar,</span>
<span class="sd">            it will be converted to an array scalar.  By default, ``self``</span>
<span class="sd">            is converted.</span>

<span class="sd">        unit : `UnitBase`, or anything convertible to a :class:`~astropy.units.Unit`, optional</span>
<span class="sd">            The unit of the resulting object.  It is used to select a</span>
<span class="sd">            subclass, and explicitly assigned to the view if given.</span>
<span class="sd">            If not given, the subclass and unit will be that of ``self``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        view : Quantity subclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine the unit and quantity subclass that we need for the view.</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span>
            <span class="n">quantity_subclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="n">quantity_subclass</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="s1">&#39;_quantity_class&#39;</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity_subclass</span><span class="p">):</span>
                <span class="n">quantity_subclass</span><span class="p">,</span> <span class="n">subok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__quantity_subclass__</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">subok</span><span class="p">:</span>
                    <span class="n">quantity_subclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>

        <span class="c1"># We only want to propagate information from ``self`` to our new view,</span>
        <span class="c1"># so obj should be a regular array.  By using ``np.array``, we also</span>
        <span class="c1"># convert python and numpy scalars, which cannot be viewed as arrays</span>
        <span class="c1"># and thus not as Quantity either, to zero-dimensional arrays.</span>
        <span class="c1"># (These are turned back into scalar in `.value`)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Take the view, set the unit, and update possible other properties</span>
        <span class="c1"># such as ``info``, ``wrap_angle`` in `Longitude`, etc.</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">quantity_subclass</span><span class="p">)</span>
        <span class="n">view</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="n">view</span><span class="o">.</span><span class="n">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">view</span>

    <span class="k">def</span> <span class="nf">_set_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the unit.</span>

<span class="sd">        This is used anywhere the unit is set or modified, i.e., in the</span>
<span class="sd">        initilizer, in ``__imul__`` and ``__itruediv__`` for in-place</span>
<span class="sd">        multiplication and division by another unit, as well as in</span>
<span class="sd">        ``__array_finalize__`` for wrapping up views.  For Quantity, it just</span>
<span class="sd">        sets the unit, but subclasses can override it to check that, e.g.,</span>
<span class="sd">        a unit is consistent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">UnitBase</span><span class="p">):</span>
            <span class="c1"># Trying to go through a string ensures that, e.g., Magnitudes with</span>
            <span class="c1"># dimensionless physical unit become Quantity with units of mag.</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">unit</span><span class="p">),</span> <span class="n">parse_strict</span><span class="o">=</span><span class="s1">&#39;silent&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">UnitBase</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">UnitTypeError</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> instances require </span><span class="si">{1}</span><span class="s2"> units, not </span><span class="si">{2}</span><span class="s2"> instances.&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">UnitBase</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">unit</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="n">unit</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="c1"># If we don&#39;t define this, ``copy.deepcopy(quantity)`` will</span>
        <span class="c1"># return a bare Numpy array.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># patch to pickle Quantity objects (ndarray subclasses), see</span>
        <span class="c1"># http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html</span>

        <span class="n">object_state</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">Quantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">())</span>
        <span class="n">object_state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">object_state</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">object_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># patch to unpickle Quantity objects (ndarray subclasses), see</span>
        <span class="c1"># http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html</span>

        <span class="n">nd_state</span><span class="p">,</span> <span class="n">own_state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Quantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">nd_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">own_state</span><span class="p">)</span>

    <span class="n">info</span> <span class="o">=</span> <span class="n">QuantityInfo</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_to_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Helper method for to and to_value.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">equivalencies</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">equivalencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equivalencies</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
                            <span class="n">equivalencies</span><span class="o">=</span><span class="n">equivalencies</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new `~astropy.units.Quantity` object with the specified unit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : `~astropy.units.UnitBase` instance, str</span>
<span class="sd">            An object that represents the unit to convert to. Must be</span>
<span class="sd">            an `~astropy.units.UnitBase` object or a string parseable</span>
<span class="sd">            by the `~astropy.units` package.</span>

<span class="sd">        equivalencies : list of equivalence pairs, optional</span>
<span class="sd">            A list of equivalence pairs to try if the units are not</span>
<span class="sd">            directly convertible.  See :ref:`unit_equivalencies`.</span>
<span class="sd">            If not provided or ``[]``, class default equivalencies will be used</span>
<span class="sd">            (none for `~astropy.units.Quantity`, but may be set for subclasses)</span>
<span class="sd">            If `None`, no equivalencies will be applied at all, not even any</span>
<span class="sd">            set globally or within a context.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        to_value : get the numerical value in a given unit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We don&#39;t use `to_value` below since we always want to make a copy</span>
        <span class="c1"># and don&#39;t want to slow down this method (esp. the scalar case).</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">),</span> <span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The numerical value, possibly in a different unit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : `~astropy.units.UnitBase` instance or str, optional</span>
<span class="sd">            The unit in which the value should be given. If not given or `None`,</span>
<span class="sd">            use the current unit.</span>

<span class="sd">        equivalencies : list of equivalence pairs, optional</span>
<span class="sd">            A list of equivalence pairs to try if the units are not directly</span>
<span class="sd">            convertible (see :ref:`unit_equivalencies`). If not provided or</span>
<span class="sd">            ``[]``, class default equivalencies will be used (none for</span>
<span class="sd">            `~astropy.units.Quantity`, but may be set for subclasses).</span>
<span class="sd">            If `None`, no equivalencies will be applied at all, not even any</span>
<span class="sd">            set globally or within a context.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : `~numpy.ndarray` or scalar</span>
<span class="sd">            The value in the units specified. For arrays, this will be a view</span>
<span class="sd">            of the data if no unit conversion was necessary.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        to : Get a new instance in a different unit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="k">else</span> <span class="n">value</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

    <span class="n">value</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">to_value</span><span class="p">,</span>
                     <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The numerical value of this instance.</span>

<span class="s2">    See also</span>
<span class="s2">    --------</span>
<span class="s2">    to_value : Get the numerical value in a given unit.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A `~astropy.units.UnitBase` object representing the unit of this</span>
<span class="sd">        quantity.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">equivalencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of equivalencies that will be applied by default during</span>
<span class="sd">        unit conversions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equivalencies</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">si</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the current `Quantity` instance with SI units. The</span>
<span class="sd">        value of the resulting object will be scaled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">si_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">si</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">si_unit</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                              <span class="n">si_unit</span> <span class="o">/</span> <span class="n">si_unit</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cgs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the current `Quantity` instance with CGS units. The</span>
<span class="sd">        value of the resulting object will be scaled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cgs_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">cgs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">cgs_unit</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                              <span class="n">cgs_unit</span> <span class="o">/</span> <span class="n">cgs_unit</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isscalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if the `value` of this quantity is a scalar, or False if it</span>
<span class="sd">        is an array-like object.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This is subtly different from `numpy.isscalar` in that</span>
<span class="sd">            `numpy.isscalar` returns False for a zero-dimensional array</span>
<span class="sd">            (e.g. ``np.array(1)``), while this is True for quantities,</span>
<span class="sd">            since quantities cannot represent true numpy scalars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># This flag controls whether convenience conversion members, such</span>
    <span class="c1"># as `q.m` equivalent to `q.to_value(u.m)` are available.  This is</span>
    <span class="c1"># not turned on on Quantity itself, but is on some subclasses of</span>
    <span class="c1"># Quantity, such as `astropy.coordinates.Angle`.</span>
    <span class="n">_include_easy_conversion_members</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@override__dir__</span>
    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quantities are able to directly convert to other units that</span>
<span class="sd">        have the same physical type.  This function is implemented in</span>
<span class="sd">        order to make autocompletion still work correctly in IPython.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_easy_conversion_members</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">extra_members</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">equivalencies</span> <span class="o">=</span> <span class="n">Unit</span><span class="o">.</span><span class="n">_normalize_equivalencies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalencies</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">equivalent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">_get_units_with_same_physical_type</span><span class="p">(</span>
                <span class="n">equivalencies</span><span class="p">):</span>
            <span class="n">extra_members</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">equivalent</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">extra_members</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quantities are able to directly convert to other units that</span>
<span class="sd">        have the same physical type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_easy_conversion_members</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;</span><span class="si">{0}</span><span class="s2">&#39; object has no &#39;</span><span class="si">{1}</span><span class="s2">&#39; member&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="n">attr</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">get_virtual_unit_attribute</span><span class="p">():</span>
            <span class="n">registry</span> <span class="o">=</span> <span class="n">get_current_unit_registry</span><span class="p">()</span><span class="o">.</span><span class="n">registry</span>
            <span class="n">to_unit</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">to_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
                    <span class="n">to_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalencies</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">get_virtual_unit_attribute</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> instance has no attribute &#39;</span><span class="si">{1}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="c1"># Equality (return False if units do not match) needs to be handled</span>
    <span class="c1"># explicitly for numpy &gt;=1.9, since it no longer traps errors.</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Quantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">DeprecationWarning</span><span class="p">:</span>
                <span class="c1"># We treat the DeprecationWarning separately, since it may</span>
                <span class="c1"># mask another Exception.  But we do not want to just use</span>
                <span class="c1"># np.equal, since super&#39;s __eq__ treats recarrays correctly.</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Quantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">DeprecationWarning</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="c1"># Arithmetic operations</span>
    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Multiplication between `Quantity` objects and other objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>  <span class="c1"># let other try to deal with it</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Quantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;In-place multiplication between `Quantity` objects and others.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Quantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__imul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Right Multiplication between `Quantity` objects and other</span>
<span class="sd">        objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Division between `Quantity` objects and other objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>  <span class="c1"># let other try to deal with it</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Quantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__truediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inplace division between `Quantity` objects and other objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Quantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__itruediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Right Division between `Quantity` objects and other objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Quantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Division between `Quantity` objects. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__truediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__idiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Division between `Quantity` objects. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__itruediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Division between `Quantity` objects. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;divmod&#39;</span><span class="p">):</span>  <span class="c1"># NUMPY_LT_1_13</span>
        <span class="c1"># In numpy 1.13, divmod goes via a ufunc and thus works without change.</span>
        <span class="k">def</span> <span class="nf">__divmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="n">other_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">result_tuple</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">other_value</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">result_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dimensionless_unscaled</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">result_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Fraction</span><span class="p">):</span>
            <span class="c1"># Avoid getting object arrays by raising the value to a Fraction.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">**</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">**</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Quantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__pow__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="c1"># For Py&gt;=3.5</span>
    <span class="k">if</span> <span class="n">NUMPY_LT_1_16</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">result_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">*</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
            <span class="n">result_array</span> <span class="o">=</span> <span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">result_array</span><span class="p">,</span> <span class="n">result_unit</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">__rmatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="n">result_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">*</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
            <span class="n">result_array</span> <span class="o">=</span> <span class="n">matmul</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">result_array</span><span class="p">,</span> <span class="n">result_unit</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">NUMPY_LT_1_13</span><span class="p">:</span>
        <span class="c1"># Pre-numpy 1.13, there was no np.positive ufunc and the copy done</span>
        <span class="c1"># by ndarray did not properly work for scalar quantities.</span>
        <span class="k">def</span> <span class="nf">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Plus the quantity.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># In numpy 1.13, a np.positive ufunc exists, but ndarray.__pos__</span>
        <span class="c1"># does not yet go through it, so we still need to define it, to allow</span>
        <span class="c1"># subclasses to override it inside __array_ufunc__.</span>
        <span class="c1"># Presumably, this can eventually be removed.</span>
        <span class="k">def</span> <span class="nf">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Plus the quantity.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">positive</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># other overrides of special functions</span>
    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">^</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;</span><span class="si">{cls}</span><span class="s2">&#39; object with a scalar value is not iterable&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="c1"># Otherwise return a generator</span>
        <span class="k">def</span> <span class="nf">quantity_iter</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">quantity_iter</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Quantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># We want zero-dimensional Quantity objects to behave like scalars,</span>
            <span class="c1"># so they should raise a TypeError rather than an IndexError.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;</span><span class="si">{cls}</span><span class="s2">&#39; object with a scalar value does not support &quot;</span>
                    <span class="s2">&quot;indexing&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="c1"># For single elements, ndarray.__getitem__ returns scalars; these</span>
        <span class="c1"># need a new view as a Quantity.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># update indices in info if the info property has been accessed</span>
        <span class="c1"># (in which case &#39;info&#39; in self.__dict__ is True; this is guaranteed</span>
        <span class="c1"># to be the case if we&#39;re part of a table).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span> <span class="ow">and</span> <span class="s1">&#39;info&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">adjust_indices</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY2</span><span class="p">:</span>  <span class="c1"># don&#39;t fall through to ndarray.__setslice__</span>
        <span class="k">def</span> <span class="nf">__setslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># __contains__ is OK</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Quantities should always be treated as non-False; there is too much</span>
<span class="sd">        potential for ambiguity otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">six</span><span class="o">.</span><span class="n">PY2</span><span class="p">:</span>
        <span class="fm">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{cls}</span><span class="s2">&#39; object with a scalar value has no &quot;</span>
                            <span class="s2">&quot;len()&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="c1"># Numerical types</span>
    <span class="k">def</span> <span class="nf">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">dimensionless_unscaled</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">UnitsError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;only dimensionless scalar quantities can be &#39;</span>
                            <span class="s1">&#39;converted to Python scalars&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">dimensionless_unscaled</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">UnitsError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;only dimensionless scalar quantities can be &#39;</span>
                            <span class="s1">&#39;converted to Python scalars&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__index__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># for indices, we do not want to mess around with scaling at all,</span>
        <span class="c1"># so unlike for float, int, we insist here on unscaled dimensionless</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_unity</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__index__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;only integer dimensionless scalar quantities &#39;</span>
                            <span class="s1">&#39;can be converted to a Python index&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY2</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__long__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">dimensionless_unscaled</span><span class="p">))</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">UnitsError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;only dimensionless scalar quantities can be &#39;</span>
                                <span class="s1">&#39;converted to Python scalars&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_unitstr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unitstr</span> <span class="o">=</span> <span class="n">_UNIT_NOT_INITIALISED</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unitstr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unitstr</span><span class="p">:</span>
            <span class="n">unitstr</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">unitstr</span>

        <span class="k">return</span> <span class="n">unitstr</span>

    <span class="c1"># Display</span>
    <span class="c1"># TODO: we may want to add a hook for dimensionless quantities?</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{0}{1:s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prefixstr</span> <span class="o">=</span> <span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span> <span class="k">if</span> <span class="n">NUMPY_LT_1_14</span> <span class="k">else</span> <span class="s1">&#39;, &#39;</span>
        <span class="n">arrstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="n">separator</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span>
                                 <span class="n">prefix</span><span class="o">=</span><span class="n">prefixstr</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{0}{1}{2:s}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefixstr</span><span class="p">,</span> <span class="n">arrstr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_latex_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a latex representation of the quantity and its unit.</span>

<span class="sd">        The behavior of this function can be altered via the</span>
<span class="sd">        `numpy.set_printoptions` function and its various keywords.  The</span>
<span class="sd">        exception to this is the ``threshold`` keyword, which is controlled via</span>
<span class="sd">        the ``[units.quantity]`` configuration item ``latex_array_threshold``.</span>
<span class="sd">        This is treated separately because the numpy default of 1000 is too big</span>
<span class="sd">        for most browsers to handle.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lstr</span>
<span class="sd">            A LaTeX string with the contents of this Quantity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># need to do try/finally because &quot;threshold&quot; cannot be overridden</span>
        <span class="c1"># with array2string</span>
        <span class="n">pops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()</span>

        <span class="n">format_spec</span> <span class="o">=</span> <span class="s1">&#39;.</span><span class="si">{}</span><span class="s1">g&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pops</span><span class="p">[</span><span class="s1">&#39;precision&#39;</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">float_formatter</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Latex</span><span class="o">.</span><span class="n">format_exponential_notation</span><span class="p">(</span><span class="n">value</span><span class="p">,</span>
                                                     <span class="n">format_spec</span><span class="o">=</span><span class="n">format_spec</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;float_kind&#39;</span><span class="p">:</span> <span class="n">float_formatter</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">conf</span><span class="o">.</span><span class="n">latex_array_threshold</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">conf</span><span class="o">.</span><span class="n">latex_array_threshold</span><span class="p">,</span>
                                    <span class="n">formatter</span><span class="o">=</span><span class="n">formatter</span><span class="p">)</span>

            <span class="c1"># the view is needed for the scalar case - value might be float</span>
            <span class="k">if</span> <span class="n">NUMPY_LT_1_14</span><span class="p">:</span>   <span class="c1"># style deprecated in 1.14</span>
                <span class="n">latex_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
                    <span class="n">style</span><span class="o">=</span><span class="p">(</span><span class="n">float_formatter</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span>
                           <span class="k">else</span> <span class="nb">repr</span><span class="p">),</span>
                    <span class="n">max_line_width</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;,~&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">latex_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
                    <span class="n">max_line_width</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;,~&#39;</span><span class="p">)</span>

            <span class="n">latex_value</span> <span class="o">=</span> <span class="n">latex_value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\dots&#39;</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="o">**</span><span class="n">pops</span><span class="p">)</span>

        <span class="c1"># Format unit</span>
        <span class="c1"># [1:-1] strips the &#39;$&#39; on either side needed for math mode</span>
        <span class="n">latex_unit</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">_repr_latex_</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># note this is unicode</span>
                      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                      <span class="k">else</span> <span class="n">_UNIT_NOT_INITIALISED</span><span class="p">)</span>

        <span class="k">return</span> <span class="sa">r</span><span class="s1">&#39;$</span><span class="si">{0}</span><span class="s1"> \; </span><span class="si">{1}</span><span class="s1">$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">latex_value</span><span class="p">,</span> <span class="n">latex_unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Format quantities using the new-style python formatting codes</span>
<span class="sd">        as specifiers for the number.</span>

<span class="sd">        If the format specifier correctly applies itself to the value,</span>
<span class="sd">        then it is used to format only the value. If it cannot be</span>
<span class="sd">        applied to the value, then it is applied to the whole string.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">)</span>
            <span class="n">full_format_spec</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
            <span class="n">full_format_spec</span> <span class="o">=</span> <span class="n">format_spec</span>

        <span class="k">return</span> <span class="nb">format</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}{1:s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="p">),</span>
                      <span class="n">full_format_spec</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a new `Quantity` with the units</span>
<span class="sd">        decomposed. Decomposed units have only irreducible units in</span>
<span class="sd">        them (see `astropy.units.UnitBase.decompose`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bases : sequence of UnitBase, optional</span>
<span class="sd">            The bases to decompose into.  When not provided,</span>
<span class="sd">            decomposes down to any irreducible units.  When provided,</span>
<span class="sd">            the decomposed result will only contain the given units.</span>
<span class="sd">            This will raises a `~astropy.units.UnitsError` if it&#39;s not possible</span>
<span class="sd">            to do so.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newq : `~astropy.units.Quantity`</span>
<span class="sd">            A new object equal to this quantity with units decomposed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decompose</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="n">bases</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allowscaledunits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a new `Quantity` with the units decomposed. Decomposed</span>
<span class="sd">        units have only irreducible units in them (see</span>
<span class="sd">        `astropy.units.UnitBase.decompose`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        allowscaledunits : bool</span>
<span class="sd">            If True, the resulting `Quantity` may have a scale factor</span>
<span class="sd">            associated with it.  If False, any scaling in the unit will</span>
<span class="sd">            be subsumed into the value of the resulting `Quantity`</span>

<span class="sd">        bases : sequence of UnitBase, optional</span>
<span class="sd">            The bases to decompose into.  When not provided,</span>
<span class="sd">            decomposes down to any irreducible units.  When provided,</span>
<span class="sd">            the decomposed result will only contain the given units.</span>
<span class="sd">            This will raises a `~astropy.units.UnitsError` if it&#39;s not possible</span>
<span class="sd">            to do so.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newq : `~astropy.units.Quantity`</span>
<span class="sd">            A new object equal to this quantity with units decomposed.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">bases</span><span class="o">=</span><span class="n">bases</span><span class="p">)</span>

        <span class="c1"># Be careful here because self.value usually is a view of self;</span>
        <span class="c1"># be sure that the original value is not being modified.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allowscaledunits</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_unit</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">):</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">new_unit</span><span class="o">.</span><span class="n">scale</span>
            <span class="n">new_unit</span> <span class="o">=</span> <span class="n">new_unit</span> <span class="o">/</span> <span class="n">new_unit</span><span class="o">.</span><span class="n">scale</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span> <span class="n">new_unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">new_unit</span><span class="p">)</span>

    <span class="c1"># These functions need to be overridden to take into account the units</span>
    <span class="c1"># Array conversion</span>
    <span class="c1"># http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-conversion</span>

    <span class="k">def</span> <span class="nf">item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">Quantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot make a list of Quantities.  Get &quot;</span>
                                  <span class="s2">&quot;list of values with q.value.list()&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_own_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">check_precision</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># We&#39;re not a Quantity, so let&#39;s try a more general conversion.</span>
            <span class="c1"># Plain arrays will be converted to dimensionless in the process,</span>
            <span class="c1"># but anything with a unit attribute will use that.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_value</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">UnitsError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="c1"># last chance: if this was not something with a unit</span>
                <span class="c1"># and is all 0, inf, or nan, we treat it as arbitrary unit.</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="n">can_have_arbitrary_unit</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
                    <span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">exc</span>

        <span class="k">if</span> <span class="n">check_precision</span><span class="p">:</span>
            <span class="n">value_dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">value_dtype</span><span class="p">:</span>
                <span class="n">self_dtype_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">value_dtype_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">value_dtype</span><span class="p">,</span>
                                             <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">self_dtype_array</span> <span class="o">==</span>
                                            <span class="n">value_dtype_array</span><span class="p">,</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value_dtype_array</span><span class="p">))):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot convert value type to array type &quot;</span>
                                    <span class="s2">&quot;without precision loss&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_value</span>

    <span class="k">def</span> <span class="nf">itemset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;itemset must have at least one argument&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">itemset</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),)))</span>

    <span class="k">def</span> <span class="nf">tostring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot write Quantities to string.  Write &quot;</span>
                                  <span class="s2">&quot;array with q.value.tostring(...).&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tofile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot write Quantities to file.  Write &quot;</span>
                                  <span class="s2">&quot;array with q.value.tofile(...)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot dump Quantities to file.  Write &quot;</span>
                                  <span class="s2">&quot;array with q.value.dump()&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dumps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot dump Quantities to string.  Write &quot;</span>
                                  <span class="s2">&quot;array with q.value.dumps()&quot;</span><span class="p">)</span>

    <span class="c1"># astype, byteswap, copy, view, getfield, setflags OK as is</span>

    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="c1"># Shape manipulation: resize cannot be done (does not own data), but</span>
    <span class="c1"># shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only</span>
    <span class="c1"># the flat iterator needs to be overwritten, otherwise single items are</span>
    <span class="c1"># returned as numbers.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A 1-D iterator over the Quantity array.</span>

<span class="sd">        This returns a ``QuantityIterator`` instance, which behaves the same</span>
<span class="sd">        as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,</span>
<span class="sd">        and is similar to, but not a subclass of, Python&#39;s built-in iterator</span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QuantityIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@flat</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">flat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># Item selection and manipulation</span>
    <span class="c1"># take, repeat, sort, compress, diagonal OK</span>
    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot choose based on quantity.  Choose &quot;</span>
                                  <span class="s2">&quot;using array with q.value.choose(...)&quot;</span><span class="p">)</span>

    <span class="c1"># ensure we do not return indices as quantities</span>
    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">check_precision</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                               <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># avoid numpy 1.6 problem</span>

    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="c1"># Calculation -- override ndarray methods to take into account units.</span>
    <span class="c1"># We use the corresponding numpy functions to evaluate the results, since</span>
    <span class="c1"># the methods do not always allow calling with keyword arguments.</span>
    <span class="c1"># For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives</span>
    <span class="c1"># TypeError: &#39;a_max&#39; is an invalid keyword argument for this function.</span>
    <span class="k">def</span> <span class="nf">_wrap_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrap a numpy function that processes self, returning a Quantity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : callable</span>
<span class="sd">            Numpy function to wrap.</span>
<span class="sd">        args : positional arguments</span>
<span class="sd">            Any positional arguments to the function beyond the first argument</span>
<span class="sd">            (which will be set to ``self``).</span>
<span class="sd">        kwargs : keyword arguments</span>
<span class="sd">            Keyword arguments to the function.</span>

<span class="sd">        If present, the following arguments are treated specially:</span>

<span class="sd">        unit : `~astropy.units.Unit`</span>
<span class="sd">            Unit of the output result.  If not given, the unit of ``self``.</span>
<span class="sd">        out : `~astropy.units.Quantity`</span>
<span class="sd">            A Quantity instance in which to store the output.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Output should always be assigned via a keyword argument, otherwise</span>
<span class="sd">        no proper account of the unit is taken.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~astropy.units.Quantity`</span>
<span class="sd">            Result of the function call, with the unit set properly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Ensure we don&#39;t loop back by turning any Quantity into array views.</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">arg</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span>
                                      <span class="k">else</span> <span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If pre-allocated output is used, check it is suitable.</span>
            <span class="c1"># This also returns array view, to ensure we don&#39;t loop back.</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_output</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">)</span>
        <span class="c1"># Apply the function and turn it back into a Quantity.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_as_quantity</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_min</span><span class="p">,</span> <span class="n">a_max</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">a_min</span><span class="p">),</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">a_max</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span>
                                   <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span>
                                   <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ptp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                                   <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_unity</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot use prod on scaled or &quot;</span>
                             <span class="s2">&quot;non-dimensionless Quantity arrays&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                                   <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">result_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">*</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">result_unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_unity</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot use cumprod on scaled or &quot;</span>
                             <span class="s2">&quot;non-dimensionless Quantity arrays&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="c1"># Calculation: override methods that do not make sense.</span>

    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot evaluate truth value of quantities. &quot;</span>
                                  <span class="s2">&quot;Evaluate array with q.value.all(...)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot evaluate truth value of quantities. &quot;</span>
                                  <span class="s2">&quot;Evaluate array with q.value.any(...)&quot;</span><span class="p">)</span>

    <span class="c1"># Calculation: numpy functions that can be overridden with methods.</span>

    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ediff1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_begin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">,</span> <span class="n">to_end</span><span class="p">,</span> <span class="n">to_begin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nansum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span>
                                   <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert values along the given axis before the given indices and return</span>
<span class="sd">        a new `~astropy.units.Quantity` object.</span>

<span class="sd">        This is a thin wrapper around the `numpy.insert` function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj : int, slice or sequence of ints</span>
<span class="sd">            Object that defines the index or indices before which ``values`` is</span>
<span class="sd">            inserted.</span>
<span class="sd">        values : array-like</span>
<span class="sd">            Values to insert.  If the type of ``values`` is different</span>
<span class="sd">            from that of quantity, ``values`` is converted to the matching type.</span>
<span class="sd">            ``values`` should be shaped so that it can be broadcast appropriately</span>
<span class="sd">            The unit of ``values`` must be consistent with this quantity.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to insert ``values``.  If ``axis`` is None then</span>
<span class="sd">            the quantity array is flattened before insertion.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~astropy.units.Quantity`</span>
<span class="sd">            A copy of quantity with ``values`` inserted.  Note that the</span>
<span class="sd">            insertion does not occur in-place: a new quantity array is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">        &gt;&gt;&gt; q = [1, 2] * u.m</span>
<span class="sd">        &gt;&gt;&gt; q.insert(0, 50 * u.cm)</span>
<span class="sd">        &lt;Quantity [ 0.5,  1.,  2.] m&gt;</span>

<span class="sd">        &gt;&gt;&gt; q = [[1, 2], [3, 4]] * u.m</span>
<span class="sd">        &gt;&gt;&gt; q.insert(1, [10, 20] * u.m, axis=0)</span>
<span class="sd">        &lt;Quantity [[  1.,  2.],</span>
<span class="sd">                   [ 10., 20.],</span>
<span class="sd">                   [  3.,  4.]] m&gt;</span>

<span class="sd">        &gt;&gt;&gt; q.insert(1, 10 * u.m, axis=1)</span>
<span class="sd">        &lt;Quantity [[  1., 10.,  2.],</span>
<span class="sd">                   [  3., 10.,  4.]] m&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out_array</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SpecificTypeQuantity</span><span class="p">(</span><span class="n">Quantity</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Superclass for Quantities of specific physical type.</span>

<span class="sd">    Subclasses of these work just like :class:`~astropy.units.Quantity`, except</span>
<span class="sd">    that they are for specific physical types (and may have methods that are</span>
<span class="sd">    only appropriate for that type).  Astropy examples are</span>
<span class="sd">    :class:`~astropy.coordinates.Angle` and</span>
<span class="sd">    :class:`~astropy.coordinates.Distance`</span>

<span class="sd">    At a minimum, subclasses should set ``_equivalent_unit`` to the unit</span>
<span class="sd">    associated with the physical type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The unit for the specific physical type.  Instances can only be created</span>
    <span class="c1"># with units that are equivalent to this.</span>
    <span class="n">_equivalent_unit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># The default unit used for views.  Even with `None`, views of arrays</span>
    <span class="c1"># without units are possible, but will have an uninitalized unit.</span>
    <span class="n">_unit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Default unit for initialization through the constructor.</span>
    <span class="n">_default_unit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># ensure that we get precedence over our superclass.</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="n">Quantity</span><span class="o">.</span><span class="n">__array_priority__</span> <span class="o">+</span> <span class="mi">10</span>

    <span class="k">def</span> <span class="nf">__quantity_subclass__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_equivalent_unit</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SpecificTypeQuantity</span><span class="p">,</span>
                         <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__quantity_subclass__</span><span class="p">(</span><span class="n">unit</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_set_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_equivalent_unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">UnitTypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> instances require units equivalent to &#39;</span><span class="si">{1}</span><span class="s2">&#39;&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equivalent_unit</span><span class="p">)</span> <span class="o">+</span>
                <span class="p">(</span><span class="s2">&quot;, but no unit was given.&quot;</span> <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span>
                 <span class="s2">&quot;, so cannot set it to &#39;</span><span class="si">{0}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unit</span><span class="p">)))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">SpecificTypeQuantity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2019, Benjamin Winkel.<br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.0.1. &nbsp;
    Last built 20 Apr 2019. <br/>
  </p>
</footer>
  </body>
</html>